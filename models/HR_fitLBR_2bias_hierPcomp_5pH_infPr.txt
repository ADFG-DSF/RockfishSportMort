
model{
 tau_comp <- 1 / sd_comp / sd_comp
 sd_comp ~ dunif(0, 10)
 
 for (s in 1:4){
## for (s in 1:5){
  tau_pH[s] <- 1 / sd_pH[s] / sd_pH[s]
  sd_pH[s] ~ dunif(0, 5)
 } 

# composition likelihoods; comp_ denoted by x_ayu in rmarkdown... ----------------------------------
 for(n in 1:N){ 
  comp_pelagic[n] ~ dbin(p_pelagic[comp_area[n], comp_year[n], comp_user[n] + 1], comp_N[n])
  comp_black[n] ~ dbin(p_black[comp_area[n], comp_year[n] , comp_user[n] + 1], comp_pelagic[n])
##  comp_yellow[n] ~ dbin(p_yellow[comp_area[n], comp_year[n], comp_user[n] + 1], comp_N[n] - comp_pelagic[n])
    }

##Southcentral Yelloweye estimates relative to all non-pelagics 
 for (n in 1:(SEn1 - 1)){
  comp_yellow[n] ~ dbin(p_yellow[comp_area[n], comp_year[n], comp_user[n] + 1], comp_N[n] - comp_pelagic[n])
 }   
 for (n in (SEn2 + 1):(SEn3 - 1)){ #for (n in (288):(449)){
  comp_yellow[n] ~ dbin(p_yellow[comp_area[n], comp_year[n], comp_user[n] + 1], comp_N[n] - comp_pelagic[n])
 }

##Southeast Yelloweye, DSR and Slope estimates. Yelloweye est relative to DSR restimates
 for (n in SEn1:SEn2){
  comp_yellow[n] ~ dbin(p_yellow[comp_area[n], comp_year[n], comp_user[n] + 1], comp_dsr[n])
  comp_dsr[n] ~ dbin(p_dsr[comp_area[n], comp_year[n], comp_user[n] + 1], comp_N[n] - comp_pelagic[n])
  comp_slope[n] ~ dbin(p_slope[comp_area[n], comp_year[n], comp_user[n] + 1], comp_N[n] - comp_pelagic[n])
 }

 for (n in SEn3:N){
  comp_yellow[n] ~ dbin(p_yellow[comp_area[n], comp_year[n], comp_user[n] + 1], comp_dsr[n])
  comp_dsr[n] ~ dbin(p_dsr[comp_area[n], comp_year[n], comp_user[n] + 1], comp_N[n] - comp_pelagic[n])
  comp_slope[n] ~ dbin(p_slope[comp_area[n], comp_year[n], comp_user[n] + 1], comp_N[n] - comp_pelagic[n])
 }

# PRIORS ----------------------------------------------------------------------------------
 for(r in 1:3){ #priors for mean composition & proportion harvested
  # SPLINE PRIORS ----------------------------------------
  alpha_lambda_H[r] <- pow(mu_lambda_H[r], 2) / pow(sigma_lambda_H[r], 2)
  beta_lambda_H[r] <- mu_lambda_H[r] / pow(sigma_lambda_H[r], 2)
  mu_lambda_H[r] ~ dnorm(1, 0.1)  # dnorm(0.5, 0.1) = weaker smoothing; (1,0.1)=more smoothing.
  sigma_lambda_H[r] ~ dunif(0, 20) #dt(0, 1, 1) T(0, ) # dunif(0, 20) 

  # COMPOSITIONAL PRIORS:---------------------------------
  mu_beta0_pelagic[r] ~ dnorm(0, 0.1) #dnorm(0, 0.001)
##  tau_beta0_pelagic[r] ~ dgamma(0.01, 0.01)
  tau_beta0_pelagic[r] <- 1 / sd_beta0_pelagic[r] / sd_beta0_pelagic[r]
  sd_beta0_pelagic[r] ~ dunif(0.1, 5)
  mu_beta0_yellow[r] ~ dnorm(0, 0.5) #dnorm(0, 0.001)
  tau_beta0_yellow[r] <- 1 / sd_beta0_yellow[r] / sd_beta0_yellow[r]
  sd_beta0_yellow[r] ~ dunif(0.1, 5)
##  tau_beta0_yellow[r] ~ dgamma(0.01, 0.01)
  mu_beta0_black[r] ~ dnorm(0, 0.1) #dnorm(0, 0.001)
##  tau_beta0_black[r] ~ dgamma(0.01, 0.01)
  tau_beta0_black[r] <- 1 / sd_beta0_black[r] / sd_beta0_black[r]
  sd_beta0_black[r] ~ dunif(0.1, 5)

  mu_beta1_pelagic[r] ~ dlnorm(log(0.0001), 0.1) 
  #tau_beta1_pelagic[r] ~ dgamma(0.1, 0.1)
  tau_beta1_pelagic[r] <- 1 / sd_beta1_pelagic[r] / sd_beta1_pelagic[r]
  sd_beta1_pelagic[r] ~ dunif(0.1, 5)
  mu_beta1_yellow[r] ~ dlnorm(log(0.0001), 0.1) 
  #tau_beta1_yellow[r] ~ dgamma(0.1, 0.1)
  tau_beta1_yellow[r] <- 1 / sd_beta1_yellow[r] / sd_beta1_yellow[r]
  sd_beta1_yellow[r] ~ dunif(0.1, 5)
  mu_beta1_black[r] ~ dlnorm(log(0.0001), 0.1) 
  #tau_beta1_black[r] ~ dgamma(0.1, 0.1)
  tau_beta1_black[r] <- 1 / sd_beta1_black[r] / sd_beta1_black[r]
  sd_beta1_black[r] ~ dunif(0.1, 5)

  mu_beta2_pelagic[r] ~ dnorm(0, 0.1) #dnorm(0, 0.001)
  tau_beta2_pelagic[r] <- 1 / sd_beta2_pelagic[r] / sd_beta2_pelagic[r]
  sd_beta2_pelagic[r] ~ dunif(0.1, 5)
  mu_beta2_yellow[r] ~ dnorm(-0.5, 0.1) #dnorm(0, 0.001)
  tau_beta2_yellow[r] <- 1 / sd_beta2_yellow[r] / sd_beta2_yellow[r]
  sd_beta2_yellow[r] ~ dunif(0.1, 5)
  mu_beta2_black[r] ~ dnorm(0, 0.1) #dnorm(0, 0.001)
  tau_beta2_black[r] <- 1 / sd_beta2_black[r] / sd_beta2_black[r]
  sd_beta2_black[r] ~ dunif(0.1, 5)

##  mu_beta3_pelagic[r]; see below, region specific: 
##  tau_beta3_pelagic[r] ~ dgamma(0.1, 0.1) 
##  tau_beta3_yellow[r] ~ dgamma(0.1, 0.1)
##  tau_beta3_black[r] ~ dgamma(0.1, 0.1)

  tau_beta3_pelagic[r] <- 1 / sd_beta3_pelagic[r] / sd_beta3_pelagic[r]
  sd_beta3_pelagic[r] ~ dunif(0.1, 4)
  tau_beta3_yellow[r] <- 1 / sd_beta3_yellow[r] / sd_beta3_yellow[r]
  sd_beta3_yellow[r] ~ dunif(0.1, 4)
  tau_beta3_black[r] <- 1 / sd_beta3_black[r] / sd_beta3_black[r]
  sd_beta3_black[r] ~ dunif(0.1, 4)

  mu_beta4_pelagic[r] ~ dnorm(0, 0.1)
  tau_beta4_pelagic[r] ~ dgamma(0.1, 0.1)
  mu_beta4_yellow[r] ~ dnorm(0, 0.1)
  tau_beta4_yellow[r] ~ dgamma(0.1, 0.1)
  mu_beta4_black[r] ~ dnorm(0, 0.1)
  tau_beta4_black[r] ~ dgamma(0.1, 0.1)
  }

# mu_beta3 for different regions based on data availability:
for (r in 1:2){
  mu_beta3_pelagic[r] ~ dunif(19,Y-3)
  mu_beta3_yellow[r] ~ dunif(19,Y-3)
  mu_beta3_black[r] ~ dunif(19,Y-3)
}

mu_beta3_pelagic[3] ~ dunif(29,Y-3)
mu_beta3_yellow[3] ~ dunif(29,Y-3)
mu_beta3_black[3] ~ dunif(29,Y-3)

#SE DSR and slope assemblages:
mu_beta0_dsr ~ dnorm(0, 0.1) #dnorm(0, 0.001)
tau_beta0_dsr <- 1 / sd_beta0_dsr / sd_beta0_dsr
sd_beta0_dsr ~ dunif(0.1, 5)
mu_beta1_dsr ~ dlnorm(log(0.0001), 0.1) 
tau_beta1_dsr <- 1 / sd_beta1_dsr / sd_beta1_dsr
sd_beta1_dsr ~ dunif(0.1, 5)
mu_beta2_dsr ~ dnorm(-0.5, 0.1) #dnorm(0, 0.001)
tau_beta2_dsr <- 1 / sd_beta2_dsr / sd_beta2_dsr
sd_beta2_dsr ~ dunif(0.1, 4)
mu_beta3_dsr ~ dunif(29,Y-3) 
tau_beta3_dsr <- 1 / sd_beta3_dsr / sd_beta3_dsr
sd_beta3_dsr ~ dunif(0.1, 5)
mu_beta4_dsr ~ dnorm(0, 0.1)
tau_beta4_dsr ~ dgamma(0.1, 0.1)

mu_beta0_slope ~ dnorm(0, 0.1) #dnorm(0, 0.001)
tau_beta0_slope <- 1 / sd_beta0_slope / sd_beta0_slope
sd_beta0_slope ~ dunif(0, 5)
mu_beta1_slope ~ dlnorm(log(0.0001), 0.1) 
tau_beta1_slope <- 1 / sd_beta1_slope / sd_beta1_slope
sd_beta1_slope ~ dunif(0, 5)
mu_beta2_slope ~ dnorm(0.1, 0.1) #dnorm(0, 0.001)
tau_beta2_slope <- 1 / sd_beta2_slope / sd_beta2_slope
sd_beta2_slope ~ dunif(0.01, 4)
mu_beta3_slope ~ dunif(29,Y-3) 
tau_beta3_slope <- 1 / sd_beta3_slope / sd_beta3_slope
sd_beta3_slope ~ dunif(0.1, 4) 
mu_beta4_slope ~ dnorm(0, 0.1)
tau_beta4_slope ~ dgamma(0.1, 0.1)

# PROPORTION HARVESTED (pH) PRIORS: -----------------------------------
# s = 1 = pelagic/black, 2 = ye, 3 = "other", 4 = DSR, 5 = slope
for (r in 1:3){
  for (s in 1:5){ 
    tau_beta0_pH[r,s] <- 1 / sd_beta0_pH[r,s] / sd_beta0_pH[r,s]
    sd_beta0_pH[r,s] ~ dunif(0.1, 5)
    tau_beta1_pH[r,s] <- 1 / sd_beta1_pH[r,s] / sd_beta1_pH[r,s]
    sd_beta1_pH[r,s] ~ dunif(0.1, 5)
    tau_beta2_pH[r,s] <- 1 / sd_beta2_pH[r,s] / sd_beta2_pH[r,s]
    sd_beta2_pH[r,s] ~ dunif(0.1, 5)
    tau_beta3_pH[r,s] <- 1 / sd_beta3_pH[r,s] / sd_beta3_pH[r,s]
    sd_beta3_pH[r,s] ~ dunif(0.1, 5)

    mu_beta4_pH[r,s] ~ dnorm(0,1) #dnorm(0,0.1)
    #tau_beta4_pH[r,s] ~ dgamma(0.1, 0.1)
    tau_beta4_pH[r,s] <- 1 / sd_beta4_pH[r,s] / sd_beta4_pH[r,s]
    sd_beta4_pH[r,s] ~ dunif(0.1, 5)
    }  
}

#Central Region pH
mu_beta0_pH[1,1] ~ dnorm(1, 0.1) #dnorm(0, 0.001)
mu_beta1_pH[1,1] ~ dlnorm(log(1.5), 0.1)
mu_beta2_pH[1,1] ~ dnorm(0.5, 0.1)
mu_beta3_pH[1,1] ~ dunif(19,Y-3) #dnorm(30, 0.01)

mu_beta0_pH[1,2] ~ dnorm(2, 0.1) #dnorm(0, 0.001)
mu_beta1_pH[1,2] ~ dlnorm(log(2), 0.1)
mu_beta2_pH[1,2] ~ dnorm(-1, 0.1)
mu_beta3_pH[1,2] ~ dunif(19,Y-3) #dnorm(45, 0.01)

mu_beta0_pH[1,3] ~ dnorm(1, 0.1) #dnorm(0, 0.001)
mu_beta1_pH[1,3] ~ dlnorm(log(2.5), 0.1)
mu_beta2_pH[1,3] ~ dnorm(0.25, 0.1)
mu_beta3_pH[1,3] ~ dunif(19,Y-3) #dnorm(37, 0.01)

#Kodiak Region pH
mu_beta0_pH[2,1] ~ dnorm(-0.5, 0.1) #dnorm(0, 0.1)
mu_beta1_pH[2,1] ~ dlnorm(log(2), 0.1)
mu_beta2_pH[2,1] ~ dnorm(0.5, 0.1)
mu_beta3_pH[2,1] ~ dunif(19,Y-3) #dnorm(30, 0.01)

mu_beta0_pH[2,2] ~ dnorm(3, 0.1) #dnorm(0, 0.001)
mu_beta1_pH[2,2] ~ dlnorm(log(0.001), 0.1)
mu_beta2_pH[2,2] ~ dnorm(0.2, 0.1)
mu_beta3_pH[2,2] ~ dunif(19,Y-3) #dnorm(30, 0.01)

mu_beta0_pH[2,3] ~ dnorm(-0.5, 0.1) #dnorm(0, 0.1)
mu_beta1_pH[2,3] ~ dlnorm(log(2.5), 0.1)
mu_beta2_pH[2,3] ~ dnorm(0.5, 0.1)
mu_beta3_pH[2,3] ~ dunif(19,Y-3) #dnorm(37, 0.01)

#Southeast Region pH
mu_beta0_pH[3,1] ~ dnorm(-0.5, 0.1) #dnorm(0, 0.001)
mu_beta1_pH[3,1] ~ dlnorm(log(3), 0.1)
mu_beta2_pH[3,1] ~ dnorm(0.75, 0.1)
mu_beta3_pH[3,1] ~ dunif(19,Y-3) #dnorm(30, 0.01)

mu_beta0_pH[3,2] ~ dnorm(-3, 0.1) #dnorm(0, 0.001)
mu_beta1_pH[3,2] ~ dlnorm(log(6), 0.1)
mu_beta2_pH[3,2] ~ dnorm(-3, 0.1)
mu_beta3_pH[3,2] ~ dunif(29,Y-3) #dnorm(43, 0.01)

# no pH[3,3] for SE "other" RF = slope + DSR - YE

mu_beta0_pH[3,4] ~ dnorm(-1, 0.1) #dnorm(0, 0.001)
mu_beta1_pH[3,4] ~ dlnorm(log(3), 0.1)
mu_beta2_pH[3,4] ~ dnorm(-3, 0.1)
mu_beta3_pH[3,4] ~ dunif(29,Y-3) #dnorm(40, 0.01)

# mu_beta0_pH[3,5] ~ dnorm(-1, 0.1) #dnorm(0, 0.001)
# mu_beta1_pH[3,5] ~ dlnorm(log(3), 0.1) #T(,50 - 100?)
# mu_beta2_pH[3,5] ~ dnorm(-3, 0.1)
# mu_beta3_pH[3,5] ~ dunif(29,Y-3) #dnorm(40, 0.01)

for (a in 1:A){
  # SWHS H and R bias PRIORS: --------------------------------------------------
  mu_bc_H[a] ~ dnorm(0, 0.001) #T(,10)              # mean log bias in SWHS H estimates
  tau_bc_H[a] <- 1 / sd_bc_H[a] / sd_bc_H[a]    # transformed sigma in mean log bias 
  sd_bc_H[a] ~ dgamma(2, 2) #dunif(0, 10)                 # sigma mean log bias 

  mu_bc_R[a] ~ dnorm(0, 0.001) #T(,10)              # mean log bias in SWHS H estimates
  tau_bc_R[a] <- 1 / sd_bc_R[a] / sd_bc_R[a]    # transformed sigma in mean log bias 
  sd_bc_R[a] ~ dgamma(2, 2) #dunif(0, 10)                 # sigma mean log bias

  #User proportions PRIORS: ---------------------------------------------------- 
  b1_pG[a] ~ dunif(1, 50)                 # beta1 for user proportion (Puser)
  b2_pG[a] ~ dunif(1, 50)                 # beta2 for user proportion (Puser)

  #pH PRIORS: proportion of catch that is harvested---------------------------
  for (s in 1:2){ #s = 1= pelagic, s = 2 = yelloweye, , s = 3 = non-pel, non-ye,  4 = dsr, 5 = slope
    beta0_pH[a,s] ~ dnorm(mu_beta0_pH[regions[a],s], tau_beta0_pH[regions[a],s]) #INTERCEPT
    beta1_pH[a,s] ~ dlnorm(log(mu_beta1_pH[regions[a],s]), tau_beta1_pH[regions[a],s]) # SCALING FACTOR (amplitude)
    beta2_pH[a,s] ~ dnorm(mu_beta2_pH[regions[a],s], tau_beta2_pH[regions[a],s]) # SLOPE 
    beta3_pH[a,s] ~ dlnorm(log(mu_beta3_pH[regions[a],s]), tau_beta3_pH[regions[a],s])T(18,Y-1) # INFLECTION POINT
    beta4_pH[a,s] ~ dnorm(mu_beta4_pH[regions[a],s], tau_beta4_pH[regions[a],s])  # USER EFFECT
  }

  # COMPOSITIONAL PRIORS --------------------------------------------------
  # logit parameters for proportion estimates defined by intercept(B0), scaleing factor(B1), slope(B2), inflection point (B3) and user effect (B4) 
  beta0_pelagic[a] ~ dnorm(mu_beta0_pelagic[regions[a]], tau_beta0_pelagic[regions[a]]) 
  beta1_pelagic[a] ~ dlnorm(log(mu_beta1_pelagic[regions[a]]), tau_beta1_pelagic[regions[a]])
  beta2_pelagic[a] ~ dnorm(mu_beta2_pelagic[regions[a]], tau_beta2_pelagic[regions[a]]) 
  beta3_pelagic[a] ~ dlnorm(log(mu_beta3_pelagic[regions[a]]), tau_beta3_pelagic[regions[a]])T(18,Y-1) 
  beta4_pelagic[a] ~ dnorm(mu_beta4_pelagic[regions[a]], tau_beta4_pelagic[regions[a]])

  beta0_yellow[a] ~ dnorm(mu_beta0_yellow[regions[a]], tau_beta0_yellow[regions[a]])
  beta1_yellow[a] ~ dlnorm(log(mu_beta1_yellow[regions[a]]), tau_beta1_yellow[regions[a]])
  beta2_yellow[a] ~ dnorm(mu_beta2_yellow[regions[a]], tau_beta2_yellow[regions[a]]) 
##  beta3_yellow[a] ~ dlnorm(log(mu_beta3_yellow[regions[a]]), tau_beta3_yellow[regions[a]])T(18,Y-1)  
  beta4_yellow[a] ~ dnorm(mu_beta4_yellow[regions[a]], tau_beta4_yellow[regions[a]]) 

  beta0_black[a] ~ dnorm(mu_beta0_black[regions[a]], tau_beta0_black[regions[a]])
  beta1_black[a] ~ dlnorm(log(mu_beta1_black[regions[a]]), tau_beta1_black[regions[a]])T(,50)
  beta2_black[a] ~ dnorm(mu_beta2_black[regions[a]], tau_beta2_black[regions[a]]) 
  beta3_black[a] ~ dlnorm(log(mu_beta3_black[regions[a]]), tau_beta3_black[regions[a]])T(18,Y-1)
  beta4_black[a] ~ dnorm(mu_beta4_black[regions[a]], tau_beta4_black[regions[a]])

## LIKELIHOODS: ------------------------------------------------------------------------------	
  for(y in 35:Y){ #guided SWHS harvest likelihood
   tauHhat_ayg[a, y] <- 1 / log(cvHhat_ayg[a, y] * cvHhat_ayg[a, y] + 1)
   Hhat_ayg[a, y] ~ dlnorm(logHhat_ay[a, y] + log(pG[a, y]), tauHhat_ayg[a, y])
  }

  for(y in 35:Y){ #guided SWHS release likelihood
   tauRhat_ayg[a, y] <- 1 / log(cvRhat_ayg[a, y] * cvRhat_ayg[a, y] + 1)
   logRhat_ayg[a, y] <- log(R_ayg[a, y]) + logbc_R[a, y] 
   Rhat_ayg[a, y] ~ dlnorm(logRhat_ayg[a, y], tauRhat_ayg[a, y])
  }

  for (y in 14:Y){ #all user SWHS release likelihood
   tauRhat_ay[a, y] <- 1 / log(cvRhat_ay[a, y] * cvRhat_ay[a, y] + 1)
   logRhat_ay[a, y] <- log(R_ay[a, y]) + logbc_R[a, y]
   Rhat_ay[a, y] ~ dlnorm(logRhat_ay[a, y], tauRhat_ay[a, y])
  }

  for(y in 22:Y){ #logbook likelihood; guided harvest by area and year
   Hlb_ayg[a, y] ~ dpois(H_ayg[a, y])   # all rockfish
   Hlbp_ayg[a, y] ~ dpois(H_ayg[a, y] * p_pelagic[a, y, 1]) #pelagic rockfish
  } 

  for (y in 23:Y) { #logbook likelihood; guided release by area and year
    Rlb_ayg[a, y] ~ dpois(R_ayg[a,y])  
    Rlbp_ayg[a, y] ~ dpois(R_ayg[a, y] * p_pelagic[a, y, 1])  
  }
  
  for(y in 30:Y){ #logbook likelihood; 
   Hlby_ayg[a, y] ~ dpois(Hy_ayg[a, y])
   Hlbo_ayg[a, y] ~ dpois(Ho_ayg[a, y])
   Rlby_ayg[a, y] ~ dpois(Ry_ayg[a, y])
   Rlbo_ayg[a,y] ~ dpois(Ro_ayg[a,y])
  }
	
  for(y in 1:Y){
   #SWHS total likelihood fit to SPLINE
   tauHhat_ay[a, y] <- 1 / log(cvHhat_ay[a, y] * cvHhat_ay[a, y] + 1)
   Hhat_ay[a, y] ~ dlnorm(logHhat_ay[a, y], tauHhat_ay[a, y])
   logHhat_ay[a, y] <- logH_ay[a, y] + logbc_H[a, y]
   logH_ay[a, y] ~ dnorm(Htrend_ay[a, y], prec_H[a])
   Htrend_ay[a, y] <- Z[y, ] %*% beta_H[a, 1:C]   # Harvest temproal trend defined by penalized spline 

   #SWHS Bias and user comp PRIORS
   logbc_H[a, y] ~ dnorm(mu_bc_H[a], tau_bc_H[a])T(-20,3)     # mean log bias in SWHS H estimates
   logbc_R[a,y] ~ dnorm(mu_bc_R[a], tau_bc_R[a])

   #pUser PRIORS
   pG[a, y] ~ dbeta(b1_pG[a], b2_pG[a])         # P(user)ay1 = frac of harv taken by charter anglers

# MODEL PROCESS: ---------------------------------------------------------------------------------
   #Harvest
   H_ayg[a, y] <- H_ay[a, y] * pG[a, y] #H_ay[a, y] * pG[a, y] # guided harvests
   H_ayu[a, y] <- H_ay[a, y] * (1 - pG[a, y])  # unguide harvests
   H_ay[a, y] <- exp(logH_ay[a, y])               # total harvest parameter

   #Catches
   C_ayg[a, y] <- H_ayg[a, y] + R_ayg[a, y]      # guided catches
   C_ayu[a, y] <- H_ayu[a, y] + R_ayu[a, y]      # unguide catches
   C_ay[a, y] <- C_ayg[a, y] + C_ayu[a, y]      # total catch parameter
   
   #Total releases
   R_ayg[a, y] <- Rp_ayg[a,y] + Ry_ayg[a,y] + Ro_ayg[a,y]  #max(0.01,(H_ayg[a, y] / pHg[a,y]) - H_ayg[a, y])  #     
   R_ayu[a, y] <- Rp_ayu[a,y] + Ry_ayu[a,y] + Ro_ayu[a,y]  #max(0.01,(H_ayu[a, y] / pHu[a,y]) - H_ayu[a, y])
   R_ay[a, y] <- max(R_ayg[a, y] + R_ayu[a, y], 0.01) #exp(logR_ay[a, y])         

   #Pelagics      
   Hp_ayg[a, y] <- H_ayg[a, y] * p_pelagic[a, y, 1]
   Hp_ayu[a, y] <- H_ayu[a, y] * p_pelagic[a, y, 2] 
   Hp_ay[a, y] <- Hp_ayg[a, y] + Hp_ayu[a, y]

   Rp_ayg[a, y] <- (Hp_ayg[a, y] / pH[a,y,1,1]) - Hp_ayg[a, y]   
   Rp_ayu[a, y] <- (Hp_ayu[a, y] / pH[a,y,2,1]) - Hp_ayu[a, y]  
   Rp_ay[a, y] <- Rp_ayg[a, y] + Rp_ayu[a, y]

   #Black rockfish
   Hb_ayg[a, y] <- H_ayg[a, y] * p_pelagic[a, y, 1] * p_black[a, y, 1]
   Hb_ayu[a, y] <- H_ayu[a, y] * p_pelagic[a, y, 2] * p_black[a, y, 2]
   Hb_ay[a, y] <- Hb_ayg[a, y] + Hb_ayu[a, y]

   Rb_ayg[a, y] <- (Hb_ayg[a, y] / pH[a,y,1,1]) - Hb_ayg[a, y]   
   Rb_ayu[a, y] <- (Hb_ayu[a, y] / pH[a,y,2,1]) - Hb_ayu[a, y]  
   Rb_ay[a, y] <- Rb_ayg[a, y] + Rb_ayu[a, y]

   #Yelloweye rockfish
   Hy_ay[a, y] <- Hy_ayg[a, y] + Hy_ayu[a, y]

   Ry_ayg[a, y] <- (Hy_ayg[a, y] / pH[a,y,1,2]) - Hy_ayg[a, y]  
   Ry_ayu[a, y] <- (Hy_ayg[a, y] / pH[a,y,2,2]) - Hy_ayg[a, y]  
   Ry_ay[a, y] <- Ry_ayg[a, y] + Ry_ayu[a, y]

   for(u in 1:2){
    #Proportion harvested logit slopes for pelagic and yelloweye: 
    for (s in 1:2) {
      logit(pH[a, y, u, s]) <- re_pH[a, y, u, s] + beta0_pH[a,s] + 
                                     beta1_pH[a,s] / (1 + exp(-beta2_pH[a,s] * (y - beta3_pH[a,s]))) + 
                                     beta4_pH[a,s] * (u - 1)
      re_pH[a, y, u, s] ~ dnorm(0, tau_pH[s])
    }
    
    #Species composition: 
    logit(p_pelagic[a, y, u]) <- re_pelagic[a, y, u] + beta0_pelagic[a] + 
                                     beta1_pelagic[a] / (1 + exp(-beta2_pelagic[a] * (y - beta3_pelagic[a]))) + beta4_pelagic[a] * (u - 1)

    logit(p_yellow[a, y, u]) <- re_yellow[a, y, u] + beta0_yellow[a] + 
                                     beta1_yellow[a] / (1 + exp(-beta2_yellow[a] * (y - beta3_yellow[a]))) + 
                                     beta4_yellow[a] * (u - 1)

    logit(p_black[a, y, u]) <- re_black[a, y, u] + beta0_black[a] + 
                                     beta1_black[a] / (1 + exp(-beta2_black[a] * (y - beta3_black[a]))) + 
                                     beta4_black[a] * (u - 1)

    re_black[a, y, u] ~ dnorm(0, tau_comp)    # random effects
    re_pelagic[a, y, u] ~ dnorm(0, tau_comp)
    re_yellow[a, y, u] ~ dnorm(0, tau_comp)
   }

  } #END EVERY YEAR

 #Spline parameters
 prec_H[a] <- pow(sigma_H[a], -2)
 sigma_H[a] ~ dnorm(0.25,1)T(0.00001,10) #~ dnorm(0,1)T(0.00001,10) #<- 0.25 
 beta_H[a, 1:C] ~ dmnorm(zero[1:C] + beta0_H[a], lambda_H[a] * Q[1:C, 1:C])
 gamma_H[a, 1:C] <- beta_H[a, 1:C] - beta0_H[a]
 beta0_H[a] ~ dnorm(0, 1e-6)

 #Lambda hierarchichal approach: smoothing penalty
 #lambda_H[a] ~ dgamma(1, 1) #dgamma(0.001, 0.001)
 #lambda_H[a] ~ dgamma(alpha_lambda_H, beta_lambda_H)
 lambda_H[a] ~ dgamma(alpha_lambda_H[regions[a]], beta_lambda_H[regions[a]])
 } # END EVERY AREA

# REGION SPECIFIC PRIORS AND CALCULATIONS --------------------------------------

 #Kodiak and Southcentral: -----------------------------------------------------
 for (a in 1:10) { #Central = 1:4, Kodiak = 5:10
  beta3_yellow[a] ~ dlnorm(log(mu_beta3_yellow[regions[a]]), tau_beta3_yellow[regions[a]])T(18,Y-1)

  beta0_pH[a,3] ~ dnorm(mu_beta0_pH[regions[a],3], tau_beta0_pH[regions[a],3]) #T(-2.75,) #INTERCEPT
  beta1_pH[a,3] ~ dlnorm(log(mu_beta1_pH[regions[a],3]), tau_beta1_pH[regions[a],3]) # SCALING FACTOR 
  beta2_pH[a,3] ~ dnorm(mu_beta2_pH[regions[a],3], tau_beta2_pH[regions[a],3]) #T(0,) # SLOPE 
  beta3_pH[a,3] ~ dlnorm(log(mu_beta3_pH[regions[a],3]), tau_beta3_pH[regions[a],3])T(18,Y-1) # INFLECTION POINT
  beta4_pH[a,3] ~ dnorm(mu_beta4_pH[regions[a],3], tau_beta4_pH[regions[a],3])               # USER EFFECT

  for (y in 1:Y){
##   pHg[a,y] <- (pH[a,y,1,1] * H_ayg[a,y] * p_pelagic[a, y, 1] + pH[a,y,1,2] * Hy_ayg[a,y] + pH[a,y,1,3] * (H_ayg[a,y] * (1 - p_pelagic[a, y, 1]) - Hy_ayg[a,y])) / H_ayg[a,y]
##   pHu[a,y] <- (pH[a,y,2,1] * H_ayu[a,y] * p_pelagic[a, y, 2] + pH[a,y,2,2] * Hy_ayu[a,y] + pH[a,y,2,3] * (H_ayu[a,y] * (1 - p_pelagic[a, y, 2]) - Hy_ayu[a,y])) / H_ayu[a,y]

   Hy_ayg[a, y] <- H_ayg[a, y] * (1 - p_pelagic[a, y, 1]) * p_yellow[a, y, 1]
   Hy_ayu[a, y] <- H_ayu[a, y] * (1 - p_pelagic[a, y, 2]) * p_yellow[a, y, 2]

   #Non Pelagic, non-YE
   Ho_ayg[a, y] <- H_ayg[a, y] * (1 - p_pelagic[a, y, 1]) * (1 - p_yellow[a, y, 1])
   Ho_ayu[a, y] <- H_ayu[a, y] * (1 - p_pelagic[a, y, 2]) * (1 - p_yellow[a, y, 2])
   Ho_ay[a, y] <- Ho_ayg[a, y] + Ho_ayu[a, y]

   Ro_ayg[a, y] <- max(0.001,(Ho_ayg[a, y] / pH[a,y,1,3]) - Ho_ayg[a, y])  
   Ro_ayu[a, y] <- max(0.001,(Ho_ayg[a, y] / pH[a,y,2,3]) - Ho_ayg[a, y] ) 
   Ro_ay[a, y] <- Ro_ayg[a, y] + Ro_ayu[a, y]

   for (u in 1:2){ #Proportion harvested logit slopes for non-pelagic, non-yelloweye:
      logit(pH[a, y, u, 3]) <- re_pH[a, y, u, 3] + beta0_pH[a,3] + 
                                     beta1_pH[a,3] / (1 + exp(-beta2_pH[a,3] * (y - beta3_pH[a,3]))) + 
                                     beta4_pH[a,3] * (u - 1)
      re_pH[a, y, u, 3] ~ dnorm(0, tau_pH[3])
   }  
  }
 } 

#Southeast: -------------------------------------------------------------------
for (a in 11:16){
  beta3_yellow[a] ~ dlnorm(log(mu_beta3_yellow[regions[a]]), tau_beta3_yellow[regions[a]])T(28,Y-1)

  beta0_dsr[a] ~ dnorm(mu_beta0_dsr, tau_beta0_dsr) #T(-5,)
  beta1_dsr[a] ~ dlnorm(log(mu_beta1_dsr), tau_beta1_dsr)
  beta2_dsr[a] ~ dnorm(mu_beta2_dsr, tau_beta2_dsr)
  beta3_dsr[a] ~ dlnorm(log(mu_beta3_dsr), tau_beta3_dsr)T(28,Y-1) 
  beta4_dsr[a] ~ dnorm(mu_beta4_dsr, tau_beta4_dsr) 

  beta0_slope[a] ~ dnorm(mu_beta0_slope, tau_beta0_slope) #T(-5,)
  beta1_slope[a] ~ dlnorm(log(mu_beta1_slope), tau_beta1_slope)
  beta2_slope[a] ~ dnorm(mu_beta2_slope, tau_beta2_slope)
  beta3_slope[a] ~ dlnorm(log(mu_beta3_slope), tau_beta3_slope)T(28,Y-1)
  beta4_slope[a] ~ dnorm(mu_beta4_slope, tau_beta4_slope)

#  for (s in 4:5){ #s = 1= pelagic, s = 2 = yelloweye, , s = 3 = non-pel, non-ye,  4 = dsr, 5 = slope
#    beta0_pH[a,s] ~ dnorm(mu_beta0_pH[regions[a],s], tau_beta0_pH[regions[a],s]) #T(-2.75,) #INTERCEPT
#    beta1_pH[a,s] ~ dlnorm(log(mu_beta1_pH[regions[a],s]), tau_beta1_pH[regions[a],s]) #T(0,) # SCALING FACTOR (amplitude)
#    beta2_pH[a,s] ~ dnorm(mu_beta2_pH[regions[a],s], tau_beta2_pH[regions[a],s]) #T(0,) # SLOPE 
#    beta3_pH[a,s] ~ dlnorm(log(mu_beta3_pH[regions[a],s]), tau_beta3_pH[regions[a],s])T(29,Y-1)# INFLECTION POINT
#    beta4_pH[a,s] ~ dnorm(mu_beta4_pH[regions[a],s], tau_beta4_pH[regions[a],s]) # USER EFFECT
#  }

  for (s in 4:5){ #s = 1= pelagic, s = 2 = yelloweye, , s = 3 = non-pel, non-ye,  4 = dsr, 5 = slope
    beta0_pH[a,s] ~ dnorm(mu_beta0_pH[regions[a],4], tau_beta0_pH[regions[a],4]) #T(-2.75,) #INTERCEPT
    beta1_pH[a,s] ~ dlnorm(log(mu_beta1_pH[regions[a],4]), tau_beta1_pH[regions[a],4]) #T(0,) # SCALING FACTOR (amplitude)
    beta2_pH[a,s] ~ dnorm(mu_beta2_pH[regions[a],4], tau_beta2_pH[regions[a],4]) #T(0,) # SLOPE 
    beta3_pH[a,s] ~ dlnorm(log(mu_beta3_pH[regions[a],4]), tau_beta3_pH[regions[a],4])T(29,Y-1)# INFLECTION POINT
    beta4_pH[a,s] ~ dnorm(mu_beta4_pH[regions[a],4], tau_beta4_pH[regions[a],4]) # USER EFFECT
  }

  for (y in 1:Y){
##    pHg[a,y] <- (pH[a,y,1,1] * H_ayg[a,y] * p_pelagic[a, y, 1] + pH[a,y,1,2] * Hy_ayg[a,y] + pH[a,y,1,4] * (Hd_ayg[a,y]-Hy_ayg[a,y]) + pH[a,y,1,5] * Hs_ayg[a,y]) / H_ayg[a,y]

##    pHu[a,y] <- (pH[a,y,2,1] * H_ayu[a,y] * p_pelagic[a, y, 2] + pH[a,y,2,2] * Hy_ayu[a,y] + pH[a,y,2,4] * (Hd_ayu[a,y]-Hy_ayg[a,y]) + pH[a,y,2,5] * Hs_ayu[a,y]) / H_ayu[a,y]

    Hy_ayg[a, y] <- Hd_ayg[a, y] * p_yellow[a, y, 1]
    Hy_ayu[a, y] <- Hd_ayu[a, y] * p_yellow[a, y, 2]

    Hd_ayg[a, y] <- H_ayg[a, y] * (1 - p_pelagic[a, y, 1]) * p_dsr[a, y, 1]
    Hd_ayu[a, y] <- H_ayu[a, y] * (1 - p_pelagic[a, y, 2]) * p_dsr[a, y, 2]
    Hd_ay[a, y] <- Hd_ayg[a, y] + Hd_ayu[a, y]

    Rd_ayg[a, y] <- max(0.001,(Hd_ayg[a, y] / pH[a,y,1,4]) - Hd_ayg[a, y])  
    Rd_ayu[a, y] <- max(0.001,(Hd_ayg[a, y] / pH[a,y,2,4]) - Hd_ayg[a, y])  
    Rd_ay[a, y] <- Rd_ayg[a, y] + Rd_ayu[a, y]

    Hs_ayg[a, y] <- H_ayg[a, y] * (1 - p_pelagic[a, y, 1]) * p_slope[a, y, 1]
    Hs_ayu[a, y] <- H_ayu[a, y] * (1 - p_pelagic[a, y, 2]) * p_slope[a, y, 2]
    Hs_ay[a, y] <- Hs_ayg[a, y] + Hs_ayu[a, y]

    Rs_ayg[a, y] <- max(0.001,(Hs_ayg[a, y] / pH[a,y,1,5]) - Hs_ayg[a, y])  
    Rs_ayu[a, y] <- max(0.001,(Hs_ayg[a, y] / pH[a,y,2,5]) - Hs_ayg[a, y])  
    Rs_ay[a, y] <- Rs_ayg[a, y] + Rs_ayu[a, y]

    Ho_ayg[a, y] <- Hs_ayg[a, y] + Hd_ayg[a, y] - Hy_ayg[a, y] 
    Ho_ayu[a, y] <- Hs_ayu[a, y] + Hd_ayu[a, y] - Hy_ayu[a, y] 
    Ho_ay[a, y] <- Ho_ayg[a, y] + Ho_ayu[a, y]

    Ro_ayg[a, y] <- max(0.001,Rs_ayg[a, y] + Rd_ayg[a, y] - Ry_ayg[a, y] ) 
    Ro_ayu[a, y] <- max(0.001,Rs_ayu[a, y] + Rd_ayu[a, y] - Ry_ayu[a, y] ) 
    Ro_ay[a, y] <- Ro_ayg[a, y] + Ro_ayu[a, y]

    for (u in 1:2){ #Proportion harvested logit slopes for DSR and slope assemblages:
      for (s in 4:5){
        logit(pH[a, y, u, s]) <- re_pH[a, y, u, s] + beta0_pH[a,s] + 
                                     beta1_pH[a,s] / (1 + exp(-beta2_pH[a,s] * (y - beta3_pH[a,s]))) + 
                                     beta4_pH[a,s] * (u - 1)
##        re_pH[a, y, u, s] ~ dnorm(0, tau_pH[s])
        re_pH[a, y, u, s] ~ dnorm(0, tau_pH[4])
      }
      
      logit(p_dsr[a, y, u]) <- re_dsr[a, y, u] + beta0_dsr[a] + 
                                     beta1_dsr[a] / (1 + exp(-beta2_dsr[a] * (y - beta3_dsr[a]))) + beta4_dsr[a] * (u - 1)

      logit(p_slope[a, y, u]) <- re_slope[a, y, u] + beta0_slope[a] + 
                                     beta1_slope[a] / (1 + exp(-beta2_slope[a] * (y - beta3_slope[a]))) + 
                                     beta4_slope[a] * (u - 1)

      re_dsr[a, y, u] ~ dnorm(0, tau_comp)    # random effects
      re_slope[a, y, u] ~ dnorm(0, tau_comp)
    }
  }
}
 
}